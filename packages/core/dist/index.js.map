{"mappings":";;;;;;;;;ACqLO,KAAK,CAAC,yCAAG,IACd,CAAU,IACmB,CAAC;QAC9B,IAAI,EAAE,CAAK;QACX,GAAG,EAAE,CAAC;QACN,GAAG,MAAQ,yCAAG,CAAC,CAAC;;QAChB,MAAM,GAAG,KAAK,GAAK,yCAAG,CAAC,KAAK,CAAC,CAAC;;QAC9B,OAAO,MAAQ,yCAAG,CAAC,CAAC;;QACpB,WAAW,GAAG,KAAK,GAAK,KAAK,CAAC,CAAC;;QAC/B,KAAK,GAAG,KAAK,GAAK,KAAK,CAAC,CAAC;;QACzB,KAAK,GAAG,KAAK,GAAK,KAAK,CAAC,CAAC;IAC3B,CAAC;;AAEM,KAAK,CAAC,yCAAE,IACb,KAAa,IACgB,CAAC;QAC9B,IAAI,EAAE,CAAI;eACV,KAAK;QACL,GAAG,GAAG,IAAI,GAAK,yCAAE,CAAC,IAAI,CAAC,KAAK;;QAC5B,MAAM,MAAQ,yCAAE,CAAC,KAAK;;QACtB,OAAO,GAAG,IAAI,GAAK,IAAI,CAAC,KAAK;;QAC7B,WAAW,MAAQ,KAAK;;QACxB,KAAK,GAAG,CAAC,EAAE,IAAI,GAAK,IAAI,CAAC,KAAK;;QAC9B,KAAK,MAAQ,yCAAE,CAAC,KAAK;IACvB,CAAC","sources":["packages/core/src/index.ts","packages/core/src/Result.ts"],"sourcesContent":["import * as result from './Result';\n\nexport {\n  result\n};","// -----------------------------------------------------------------------------\n// model\n// -----------------------------------------------------------------------------\n\n/**\n * `Err` meaning that there was some failure.\n */\nexport type Err<ErrType, OkType> = ResultOperations<ErrType, OkType> &\n  ResultDeconstructors<ErrType, OkType> & {\n    readonly _tag: \"err\";\n    readonly err: ErrType;\n  };\n\n/**\n * `Ok` meaning the computation succeeded\n */\nexport type Ok<ErrType, OkType> = ResultOperations<ErrType, OkType> &\n  ResultDeconstructors<ErrType, OkType> & {\n    readonly _tag: \"ok\";\n    readonly value: OkType;\n  };\n\n/**\n * A `Result` is the result of a computation that may fail. This is a great way to manage errors.\n *\n * A `Result` is either `Ok` meaning the computation succeeded, or it is an `Err` meaning that there was some failure.\n */\nexport type Result<ErrType, OkType> =\n  | Err<ErrType, OkType>\n  | Ok<ErrType, OkType>;\n\n// -----------------------------------------------------------------------------\n// interfaces\n// -----------------------------------------------------------------------------\n\ntype ResultOperations<ErrType, OkType> = {\n  /**\n   * Applies the given function `onOk` to its `value` only if the `Result` is `Ok` and returns the result of `onOk(value)` as a new `Ok`.\n   * Otherwise, if the `Result` is `Err` it does nothing and returns the current `Result` unchanged.\n   *\n   * This is usefull if you want to modify the `value` only in the case of `Ok`.\n   *\n   * @example\n   * import type { Result } from \"@types/Result\";\n   *\n   * declare function divide12By(num: Number): Result<string, number>;\n   *\n   * const resultOk = divide12By(3).map(num => num + 4);\n   * // resultOk <== 'Ok 8'\n   *\n   * const resultErr = divide12By(0).map(num => num + 4);\n   * /// resultErr <== 'Err \"You can not devide by 0\"'\n   *\n   */\n  map: <OkReturn>(\n    onOk: (value: OkType) => OkReturn\n  ) => Result<ErrType, OkReturn>;\n\n  /**\n   * Applies the given function `onOk` to its `value` only if the `Result` is `Ok`. Instead of wrapping the result of `onOk(value)` into a new `Ok`\n   * like `map`, `andThen` expects `onOk` to return a `Result<ErrType, OkType>` itself. If the `Result` is `Err` it does nothing and returns the current `Result` unchanged.\n   *\n   * This is usefull if you want to chain multiple functions together that might fail, each depending on the result of the function which came before.\n   *\n   * So you can read it like: \"try `thisFunctionThatMightFail` with `value` `andThen`, if it did succeed try this `otherFunctionThatMightFail` with the `result` of the first function\"\n   *\n   * @example\n   * import type { Result } from \"@types/Result\";\n   *\n   * declare function divide12By(num: Number): Result<string, number>;\n   *\n   * // let's suppose this function expects num to be a hole number and fails otherwise\n   * declare function addHoleNumberBy4(num: Number): Result<string, number>;\n   *\n   * const resultOk = divide12By(3)\n   *  .andThen(addHoleNumberBy4); // since 12 / 3 = 4 `addHoleNumberBy4` will succeed\n   * // resultOk <== 'Ok 8'\n   *\n   * const resultErr = divide12By(9)\n   *  .andThen(addHoleNumberBy4); // since 12 / 9 = 1.33333 `addHoleNumberBy4` fails\n   * // resultErr <== 'Err \"Only hole number can be added by 4, as everybody knows\"'\n   */\n  mapErr: <ErrReturn>(\n    onErr: (err: ErrType) => ErrReturn\n  ) => Result<ErrReturn, OkType>;\n\n  /**\n   * Applies the given function `onErr` to its `err` only if the `Result` is `Err` and returns the result of `onErr(err)` as a new `Err`.\n   * Otherwise, if the `Result` is `Ok` it does nothing and returns the current `Result` unchanged.\n   *\n   * This is usefull if you want to modify the `err` only in the case of `Err`.\n   *\n   * @example\n   * import type { Result } from \"@types/Result\";\n   *\n   * declare function divide12By(num: Number): Result<string, number>;\n   *\n   * const resultOk = divide12By(3).mapErr(error => `Seems this didn't go well: ${error}`);\n   * // resultOk <== 'Ok 4'\n   *\n   * const resultErr = divide12By(0).mapErr(error => `Seems this didn't go well: ${error}`);\n   * /// resultErr <== 'Err \"Seems this didn't go well: You can not devide by 0\"'\n   *\n   */\n  andThen: <ErrReturn, OkReturn>(\n    onOk: (value: OkType) => Result<ErrReturn, OkReturn>\n  ) => Result<ErrType, OkType> | Result<ErrReturn, OkReturn>;\n\n  /**\n   * Applies the given function `onErr` to its `err` only if the `Result` is `Err`. Instead of wrapping the result of `onErr(err)` into a new `Err`\n   * like `mapErr`, `catch` expects `onErr` to return a `Result<ErrType, OkType>` itself. If the `Result` is `Ok` it does nothing and returns the current `Result` unchanged.\n   *\n   * This is usefull if you want to recover from a failed function call.\n   *\n   * So you can read it like this: Try `thisFunctionThatMightFail` with `value`, if it fails `catch` the Error with `recoverFunction`.\n   *\n   * @example\n   * import type { Result } from \"@types/Result\";\n   * import { ok } from \"@types/Result\";\n   *\n   * declare function divide12By(num: Number): Result<string, number>;\n   *\n   * const resultOk = divide12By(0)\n   *   // divide12By(0) fails, so recover from the Error and set it to ok(0)\n   *   .catch(() => ok(0));\n   * // resultOk <== 'Ok 0'\n   */\n  catch: <ErrReturn, OkReturn>(\n    onErr: (err: ErrType) => Result<ErrReturn, OkReturn>\n  ) => Result<ErrType, OkType> | Result<ErrReturn, OkReturn>;\n};\n\ntype ResultDeconstructors<ErrType, OkType> = {\n  /**\n   * Returns the `value` if the `Result` is `Ok` otherwise it returns the result of `onErr(err)`.\n   *\n   * @example\n   * import type { Result } from \"@types/Result\";\n   *\n   * declare function divide12By(num: Number): Result<string, number>;\n   *\n   * const resultNumber: number = divide12By(0)\n   *   .withDefault(() => 0);\n   * // resultNumber === 0\n   *\n   * const resultUnion: number | Error = divide12By(0)\n   *   .withDefault((err: string) => new Error(err));\n   * // resultNumber === Error(\"Only hole number can be added by 4, as everybody knows\");\n   */\n  withDefault: <DefaultType>(\n    onErr: (err: ErrType) => DefaultType\n  ) => OkType | DefaultType;\n\n  /**\n   * If the `Result` is `Err` it return `onErr(err)` if it is `Ok` it return `onOk(value)`.\n   *\n   * This is usefull if you want to unwrap the `Result` and want to apply a function to both of the possible cases.\n   *\n   * @example\n   * import type { Result } from \"@types/Result\";\n   *\n   * declare function divide12By(num: Number): Result<string, number>;\n   *\n   * const divide12ByMessage = (num: number): string => divide12By(num)\n   *   .match(\n   *     err => `Can not devide 12 by ${numm} => ${err}`,\n   *     value => `12 / ${num} = ${value}`\n   *   );\n   *\n   * console.log(divide12ByMessage(4)); // --> 12 / 3 = 4\n   * console.log(divide12ByMessage(0)); // --> Can not devide 12 by 0 => Only hole number can be added by 4, as everybody knows\n   */\n  match: <ErrReturn, OkReturn>(\n    onErr: (err: ErrType) => ErrReturn,\n    onOk: (value: OkType) => OkReturn\n  ) => OkReturn | ErrReturn;\n};\n\n// -----------------------------------------------------------------------------\n// constructors\n// -----------------------------------------------------------------------------\nexport const err = <ErrType = never, OkType = never>(\n  e: ErrType\n): Result<ErrType, OkType> => ({\n  _tag: \"err\",\n  err: e,\n  map: () => err(e),\n  mapErr: (onErr) => err(onErr(e)),\n  andThen: () => err(e),\n  withDefault: (onErr) => onErr(e),\n  match: (onErr) => onErr(e),\n  catch: (onErr) => onErr(e),\n});\n\nexport const ok = <ErrType = never, OkType = never>(\n  value: OkType\n): Result<ErrType, OkType> => ({\n  _tag: \"ok\",\n  value,\n  map: (onOk) => ok(onOk(value)),\n  mapErr: () => ok(value),\n  andThen: (onOk) => onOk(value),\n  withDefault: () => value,\n  match: (_, onOk) => onOk(value),\n  catch: () => ok(value),\n});\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../../../"}